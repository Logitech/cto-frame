// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Texture.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Texture_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Texture_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Size.pb.h"
#include "Pixel.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Texture_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Texture_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Texture_2eproto;
namespace frame {
namespace proto {
class Texture;
class TextureDefaultTypeInternal;
extern TextureDefaultTypeInternal _Texture_default_instance_;
class TextureFilter;
class TextureFilterDefaultTypeInternal;
extern TextureFilterDefaultTypeInternal _TextureFilter_default_instance_;
}  // namespace proto
}  // namespace frame
PROTOBUF_NAMESPACE_OPEN
template<> ::frame::proto::Texture* Arena::CreateMaybeMessage<::frame::proto::Texture>(Arena*);
template<> ::frame::proto::TextureFilter* Arena::CreateMaybeMessage<::frame::proto::TextureFilter>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace frame {
namespace proto {

enum TextureFilter_Enum : int {
  TextureFilter_Enum_INVALID = 0,
  TextureFilter_Enum_NEAREST = 1,
  TextureFilter_Enum_LINEAR = 2,
  TextureFilter_Enum_NEAREST_MIPMAP_NEAREST = 3,
  TextureFilter_Enum_LINEAR_MIPMAP_NEAREST = 4,
  TextureFilter_Enum_NEAREST_MIPMAP_LINEAR = 5,
  TextureFilter_Enum_LINEAR_MIPMAP_LINEAR = 6,
  TextureFilter_Enum_CLAMP_TO_EDGE = 7,
  TextureFilter_Enum_MIRRORED_REPEAT = 8,
  TextureFilter_Enum_REPEAT = 9,
  TextureFilter_Enum_TextureFilter_Enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TextureFilter_Enum_TextureFilter_Enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TextureFilter_Enum_IsValid(int value);
constexpr TextureFilter_Enum TextureFilter_Enum_Enum_MIN = TextureFilter_Enum_INVALID;
constexpr TextureFilter_Enum TextureFilter_Enum_Enum_MAX = TextureFilter_Enum_REPEAT;
constexpr int TextureFilter_Enum_Enum_ARRAYSIZE = TextureFilter_Enum_Enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TextureFilter_Enum_descriptor();
template<typename T>
inline const std::string& TextureFilter_Enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TextureFilter_Enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TextureFilter_Enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TextureFilter_Enum_descriptor(), enum_t_value);
}
inline bool TextureFilter_Enum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TextureFilter_Enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TextureFilter_Enum>(
    TextureFilter_Enum_descriptor(), name, value);
}
// ===================================================================

class TextureFilter PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frame.proto.TextureFilter) */ {
 public:
  inline TextureFilter() : TextureFilter(nullptr) {}
  virtual ~TextureFilter();

  TextureFilter(const TextureFilter& from);
  TextureFilter(TextureFilter&& from) noexcept
    : TextureFilter() {
    *this = ::std::move(from);
  }

  inline TextureFilter& operator=(const TextureFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextureFilter& operator=(TextureFilter&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TextureFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextureFilter* internal_default_instance() {
    return reinterpret_cast<const TextureFilter*>(
               &_TextureFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TextureFilter& a, TextureFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(TextureFilter* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextureFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TextureFilter* New() const final {
    return CreateMaybeMessage<TextureFilter>(nullptr);
  }

  TextureFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TextureFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TextureFilter& from);
  void MergeFrom(const TextureFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextureFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frame.proto.TextureFilter";
  }
  protected:
  explicit TextureFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Texture_2eproto);
    return ::descriptor_table_Texture_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TextureFilter_Enum Enum;
  static constexpr Enum INVALID =
    TextureFilter_Enum_INVALID;
  static constexpr Enum NEAREST =
    TextureFilter_Enum_NEAREST;
  static constexpr Enum LINEAR =
    TextureFilter_Enum_LINEAR;
  static constexpr Enum NEAREST_MIPMAP_NEAREST =
    TextureFilter_Enum_NEAREST_MIPMAP_NEAREST;
  static constexpr Enum LINEAR_MIPMAP_NEAREST =
    TextureFilter_Enum_LINEAR_MIPMAP_NEAREST;
  static constexpr Enum NEAREST_MIPMAP_LINEAR =
    TextureFilter_Enum_NEAREST_MIPMAP_LINEAR;
  static constexpr Enum LINEAR_MIPMAP_LINEAR =
    TextureFilter_Enum_LINEAR_MIPMAP_LINEAR;
  static constexpr Enum CLAMP_TO_EDGE =
    TextureFilter_Enum_CLAMP_TO_EDGE;
  static constexpr Enum MIRRORED_REPEAT =
    TextureFilter_Enum_MIRRORED_REPEAT;
  static constexpr Enum REPEAT =
    TextureFilter_Enum_REPEAT;
  static inline bool Enum_IsValid(int value) {
    return TextureFilter_Enum_IsValid(value);
  }
  static constexpr Enum Enum_MIN =
    TextureFilter_Enum_Enum_MIN;
  static constexpr Enum Enum_MAX =
    TextureFilter_Enum_Enum_MAX;
  static constexpr int Enum_ARRAYSIZE =
    TextureFilter_Enum_Enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Enum_descriptor() {
    return TextureFilter_Enum_descriptor();
  }
  template<typename T>
  static inline const std::string& Enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Enum_Name.");
    return TextureFilter_Enum_Name(enum_t_value);
  }
  static inline bool Enum_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Enum* value) {
    return TextureFilter_Enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .frame.proto.TextureFilter.Enum value = 1;
  void clear_value();
  ::frame::proto::TextureFilter_Enum value() const;
  void set_value(::frame::proto::TextureFilter_Enum value);
  private:
  ::frame::proto::TextureFilter_Enum _internal_value() const;
  void _internal_set_value(::frame::proto::TextureFilter_Enum value);
  public:

  // @@protoc_insertion_point(class_scope:frame.proto.TextureFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Texture_2eproto;
};
// -------------------------------------------------------------------

class Texture PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frame.proto.Texture) */ {
 public:
  inline Texture() : Texture(nullptr) {}
  virtual ~Texture();

  Texture(const Texture& from);
  Texture(Texture&& from) noexcept
    : Texture() {
    *this = ::std::move(from);
  }

  inline Texture& operator=(const Texture& from) {
    CopyFrom(from);
    return *this;
  }
  inline Texture& operator=(Texture&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Texture& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Texture* internal_default_instance() {
    return reinterpret_cast<const Texture*>(
               &_Texture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Texture& a, Texture& b) {
    a.Swap(&b);
  }
  inline void Swap(Texture* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Texture* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Texture* New() const final {
    return CreateMaybeMessage<Texture>(nullptr);
  }

  Texture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Texture>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Texture& from);
  void MergeFrom(const Texture& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Texture* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frame.proto.Texture";
  }
  protected:
  explicit Texture(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Texture_2eproto);
    return ::descriptor_table_Texture_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPixelsFieldNumber = 30,
    kSizeFieldNumber = 2,
    kPixelElementSizeFieldNumber = 10,
    kPixelStructureFieldNumber = 11,
    kMinFilterFieldNumber = 21,
    kMagFilterFieldNumber = 22,
    kWrapSFieldNumber = 23,
    kWrapTFieldNumber = 24,
    kClearFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes pixels = 30;
  void clear_pixels();
  const std::string& pixels() const;
  void set_pixels(const std::string& value);
  void set_pixels(std::string&& value);
  void set_pixels(const char* value);
  void set_pixels(const void* value, size_t size);
  std::string* mutable_pixels();
  std::string* release_pixels();
  void set_allocated_pixels(std::string* pixels);
  private:
  const std::string& _internal_pixels() const;
  void _internal_set_pixels(const std::string& value);
  std::string* _internal_mutable_pixels();
  public:

  // .frame.proto.Size size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::frame::proto::Size& size() const;
  ::frame::proto::Size* release_size();
  ::frame::proto::Size* mutable_size();
  void set_allocated_size(::frame::proto::Size* size);
  private:
  const ::frame::proto::Size& _internal_size() const;
  ::frame::proto::Size* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::frame::proto::Size* size);
  ::frame::proto::Size* unsafe_arena_release_size();

  // .frame.proto.PixelElementSize pixel_element_size = 10;
  bool has_pixel_element_size() const;
  private:
  bool _internal_has_pixel_element_size() const;
  public:
  void clear_pixel_element_size();
  const ::frame::proto::PixelElementSize& pixel_element_size() const;
  ::frame::proto::PixelElementSize* release_pixel_element_size();
  ::frame::proto::PixelElementSize* mutable_pixel_element_size();
  void set_allocated_pixel_element_size(::frame::proto::PixelElementSize* pixel_element_size);
  private:
  const ::frame::proto::PixelElementSize& _internal_pixel_element_size() const;
  ::frame::proto::PixelElementSize* _internal_mutable_pixel_element_size();
  public:
  void unsafe_arena_set_allocated_pixel_element_size(
      ::frame::proto::PixelElementSize* pixel_element_size);
  ::frame::proto::PixelElementSize* unsafe_arena_release_pixel_element_size();

  // .frame.proto.PixelStructure pixel_structure = 11;
  bool has_pixel_structure() const;
  private:
  bool _internal_has_pixel_structure() const;
  public:
  void clear_pixel_structure();
  const ::frame::proto::PixelStructure& pixel_structure() const;
  ::frame::proto::PixelStructure* release_pixel_structure();
  ::frame::proto::PixelStructure* mutable_pixel_structure();
  void set_allocated_pixel_structure(::frame::proto::PixelStructure* pixel_structure);
  private:
  const ::frame::proto::PixelStructure& _internal_pixel_structure() const;
  ::frame::proto::PixelStructure* _internal_mutable_pixel_structure();
  public:
  void unsafe_arena_set_allocated_pixel_structure(
      ::frame::proto::PixelStructure* pixel_structure);
  ::frame::proto::PixelStructure* unsafe_arena_release_pixel_structure();

  // .frame.proto.TextureFilter min_filter = 21;
  bool has_min_filter() const;
  private:
  bool _internal_has_min_filter() const;
  public:
  void clear_min_filter();
  const ::frame::proto::TextureFilter& min_filter() const;
  ::frame::proto::TextureFilter* release_min_filter();
  ::frame::proto::TextureFilter* mutable_min_filter();
  void set_allocated_min_filter(::frame::proto::TextureFilter* min_filter);
  private:
  const ::frame::proto::TextureFilter& _internal_min_filter() const;
  ::frame::proto::TextureFilter* _internal_mutable_min_filter();
  public:
  void unsafe_arena_set_allocated_min_filter(
      ::frame::proto::TextureFilter* min_filter);
  ::frame::proto::TextureFilter* unsafe_arena_release_min_filter();

  // .frame.proto.TextureFilter mag_filter = 22;
  bool has_mag_filter() const;
  private:
  bool _internal_has_mag_filter() const;
  public:
  void clear_mag_filter();
  const ::frame::proto::TextureFilter& mag_filter() const;
  ::frame::proto::TextureFilter* release_mag_filter();
  ::frame::proto::TextureFilter* mutable_mag_filter();
  void set_allocated_mag_filter(::frame::proto::TextureFilter* mag_filter);
  private:
  const ::frame::proto::TextureFilter& _internal_mag_filter() const;
  ::frame::proto::TextureFilter* _internal_mutable_mag_filter();
  public:
  void unsafe_arena_set_allocated_mag_filter(
      ::frame::proto::TextureFilter* mag_filter);
  ::frame::proto::TextureFilter* unsafe_arena_release_mag_filter();

  // .frame.proto.TextureFilter wrap_s = 23;
  bool has_wrap_s() const;
  private:
  bool _internal_has_wrap_s() const;
  public:
  void clear_wrap_s();
  const ::frame::proto::TextureFilter& wrap_s() const;
  ::frame::proto::TextureFilter* release_wrap_s();
  ::frame::proto::TextureFilter* mutable_wrap_s();
  void set_allocated_wrap_s(::frame::proto::TextureFilter* wrap_s);
  private:
  const ::frame::proto::TextureFilter& _internal_wrap_s() const;
  ::frame::proto::TextureFilter* _internal_mutable_wrap_s();
  public:
  void unsafe_arena_set_allocated_wrap_s(
      ::frame::proto::TextureFilter* wrap_s);
  ::frame::proto::TextureFilter* unsafe_arena_release_wrap_s();

  // .frame.proto.TextureFilter wrap_t = 24;
  bool has_wrap_t() const;
  private:
  bool _internal_has_wrap_t() const;
  public:
  void clear_wrap_t();
  const ::frame::proto::TextureFilter& wrap_t() const;
  ::frame::proto::TextureFilter* release_wrap_t();
  ::frame::proto::TextureFilter* mutable_wrap_t();
  void set_allocated_wrap_t(::frame::proto::TextureFilter* wrap_t);
  private:
  const ::frame::proto::TextureFilter& _internal_wrap_t() const;
  ::frame::proto::TextureFilter* _internal_mutable_wrap_t();
  public:
  void unsafe_arena_set_allocated_wrap_t(
      ::frame::proto::TextureFilter* wrap_t);
  ::frame::proto::TextureFilter* unsafe_arena_release_wrap_t();

  // bool clear = 3;
  void clear_clear();
  bool clear() const;
  void set_clear(bool value);
  private:
  bool _internal_clear() const;
  void _internal_set_clear(bool value);
  public:

  // @@protoc_insertion_point(class_scope:frame.proto.Texture)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pixels_;
  ::frame::proto::Size* size_;
  ::frame::proto::PixelElementSize* pixel_element_size_;
  ::frame::proto::PixelStructure* pixel_structure_;
  ::frame::proto::TextureFilter* min_filter_;
  ::frame::proto::TextureFilter* mag_filter_;
  ::frame::proto::TextureFilter* wrap_s_;
  ::frame::proto::TextureFilter* wrap_t_;
  bool clear_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Texture_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TextureFilter

// .frame.proto.TextureFilter.Enum value = 1;
inline void TextureFilter::clear_value() {
  value_ = 0;
}
inline ::frame::proto::TextureFilter_Enum TextureFilter::_internal_value() const {
  return static_cast< ::frame::proto::TextureFilter_Enum >(value_);
}
inline ::frame::proto::TextureFilter_Enum TextureFilter::value() const {
  // @@protoc_insertion_point(field_get:frame.proto.TextureFilter.value)
  return _internal_value();
}
inline void TextureFilter::_internal_set_value(::frame::proto::TextureFilter_Enum value) {
  
  value_ = value;
}
inline void TextureFilter::set_value(::frame::proto::TextureFilter_Enum value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:frame.proto.TextureFilter.value)
}

// -------------------------------------------------------------------

// Texture

// string name = 1;
inline void Texture::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Texture::name() const {
  // @@protoc_insertion_point(field_get:frame.proto.Texture.name)
  return _internal_name();
}
inline void Texture::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:frame.proto.Texture.name)
}
inline std::string* Texture::mutable_name() {
  // @@protoc_insertion_point(field_mutable:frame.proto.Texture.name)
  return _internal_mutable_name();
}
inline const std::string& Texture::_internal_name() const {
  return name_.Get();
}
inline void Texture::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Texture::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:frame.proto.Texture.name)
}
inline void Texture::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:frame.proto.Texture.name)
}
inline void Texture::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:frame.proto.Texture.name)
}
inline std::string* Texture::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Texture::release_name() {
  // @@protoc_insertion_point(field_release:frame.proto.Texture.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Texture::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:frame.proto.Texture.name)
}

// .frame.proto.Size size = 2;
inline bool Texture::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool Texture::has_size() const {
  return _internal_has_size();
}
inline const ::frame::proto::Size& Texture::_internal_size() const {
  const ::frame::proto::Size* p = size_;
  return p != nullptr ? *p : *reinterpret_cast<const ::frame::proto::Size*>(
      &::frame::proto::_Size_default_instance_);
}
inline const ::frame::proto::Size& Texture::size() const {
  // @@protoc_insertion_point(field_get:frame.proto.Texture.size)
  return _internal_size();
}
inline void Texture::unsafe_arena_set_allocated_size(
    ::frame::proto::Size* size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.Texture.size)
}
inline ::frame::proto::Size* Texture::release_size() {
  
  ::frame::proto::Size* temp = size_;
  size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::frame::proto::Size* Texture::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:frame.proto.Texture.size)
  
  ::frame::proto::Size* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::frame::proto::Size* Texture::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::Size>(GetArena());
    size_ = p;
  }
  return size_;
}
inline ::frame::proto::Size* Texture::mutable_size() {
  // @@protoc_insertion_point(field_mutable:frame.proto.Texture.size)
  return _internal_mutable_size();
}
inline void Texture::set_allocated_size(::frame::proto::Size* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size)->GetArena();
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.Texture.size)
}

// bool clear = 3;
inline void Texture::clear_clear() {
  clear_ = false;
}
inline bool Texture::_internal_clear() const {
  return clear_;
}
inline bool Texture::clear() const {
  // @@protoc_insertion_point(field_get:frame.proto.Texture.clear)
  return _internal_clear();
}
inline void Texture::_internal_set_clear(bool value) {
  
  clear_ = value;
}
inline void Texture::set_clear(bool value) {
  _internal_set_clear(value);
  // @@protoc_insertion_point(field_set:frame.proto.Texture.clear)
}

// .frame.proto.PixelElementSize pixel_element_size = 10;
inline bool Texture::_internal_has_pixel_element_size() const {
  return this != internal_default_instance() && pixel_element_size_ != nullptr;
}
inline bool Texture::has_pixel_element_size() const {
  return _internal_has_pixel_element_size();
}
inline const ::frame::proto::PixelElementSize& Texture::_internal_pixel_element_size() const {
  const ::frame::proto::PixelElementSize* p = pixel_element_size_;
  return p != nullptr ? *p : *reinterpret_cast<const ::frame::proto::PixelElementSize*>(
      &::frame::proto::_PixelElementSize_default_instance_);
}
inline const ::frame::proto::PixelElementSize& Texture::pixel_element_size() const {
  // @@protoc_insertion_point(field_get:frame.proto.Texture.pixel_element_size)
  return _internal_pixel_element_size();
}
inline void Texture::unsafe_arena_set_allocated_pixel_element_size(
    ::frame::proto::PixelElementSize* pixel_element_size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pixel_element_size_);
  }
  pixel_element_size_ = pixel_element_size;
  if (pixel_element_size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.Texture.pixel_element_size)
}
inline ::frame::proto::PixelElementSize* Texture::release_pixel_element_size() {
  
  ::frame::proto::PixelElementSize* temp = pixel_element_size_;
  pixel_element_size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::frame::proto::PixelElementSize* Texture::unsafe_arena_release_pixel_element_size() {
  // @@protoc_insertion_point(field_release:frame.proto.Texture.pixel_element_size)
  
  ::frame::proto::PixelElementSize* temp = pixel_element_size_;
  pixel_element_size_ = nullptr;
  return temp;
}
inline ::frame::proto::PixelElementSize* Texture::_internal_mutable_pixel_element_size() {
  
  if (pixel_element_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::PixelElementSize>(GetArena());
    pixel_element_size_ = p;
  }
  return pixel_element_size_;
}
inline ::frame::proto::PixelElementSize* Texture::mutable_pixel_element_size() {
  // @@protoc_insertion_point(field_mutable:frame.proto.Texture.pixel_element_size)
  return _internal_mutable_pixel_element_size();
}
inline void Texture::set_allocated_pixel_element_size(::frame::proto::PixelElementSize* pixel_element_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pixel_element_size_);
  }
  if (pixel_element_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pixel_element_size)->GetArena();
    if (message_arena != submessage_arena) {
      pixel_element_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pixel_element_size, submessage_arena);
    }
    
  } else {
    
  }
  pixel_element_size_ = pixel_element_size;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.Texture.pixel_element_size)
}

// .frame.proto.PixelStructure pixel_structure = 11;
inline bool Texture::_internal_has_pixel_structure() const {
  return this != internal_default_instance() && pixel_structure_ != nullptr;
}
inline bool Texture::has_pixel_structure() const {
  return _internal_has_pixel_structure();
}
inline const ::frame::proto::PixelStructure& Texture::_internal_pixel_structure() const {
  const ::frame::proto::PixelStructure* p = pixel_structure_;
  return p != nullptr ? *p : *reinterpret_cast<const ::frame::proto::PixelStructure*>(
      &::frame::proto::_PixelStructure_default_instance_);
}
inline const ::frame::proto::PixelStructure& Texture::pixel_structure() const {
  // @@protoc_insertion_point(field_get:frame.proto.Texture.pixel_structure)
  return _internal_pixel_structure();
}
inline void Texture::unsafe_arena_set_allocated_pixel_structure(
    ::frame::proto::PixelStructure* pixel_structure) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pixel_structure_);
  }
  pixel_structure_ = pixel_structure;
  if (pixel_structure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.Texture.pixel_structure)
}
inline ::frame::proto::PixelStructure* Texture::release_pixel_structure() {
  
  ::frame::proto::PixelStructure* temp = pixel_structure_;
  pixel_structure_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::frame::proto::PixelStructure* Texture::unsafe_arena_release_pixel_structure() {
  // @@protoc_insertion_point(field_release:frame.proto.Texture.pixel_structure)
  
  ::frame::proto::PixelStructure* temp = pixel_structure_;
  pixel_structure_ = nullptr;
  return temp;
}
inline ::frame::proto::PixelStructure* Texture::_internal_mutable_pixel_structure() {
  
  if (pixel_structure_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::PixelStructure>(GetArena());
    pixel_structure_ = p;
  }
  return pixel_structure_;
}
inline ::frame::proto::PixelStructure* Texture::mutable_pixel_structure() {
  // @@protoc_insertion_point(field_mutable:frame.proto.Texture.pixel_structure)
  return _internal_mutable_pixel_structure();
}
inline void Texture::set_allocated_pixel_structure(::frame::proto::PixelStructure* pixel_structure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pixel_structure_);
  }
  if (pixel_structure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pixel_structure)->GetArena();
    if (message_arena != submessage_arena) {
      pixel_structure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pixel_structure, submessage_arena);
    }
    
  } else {
    
  }
  pixel_structure_ = pixel_structure;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.Texture.pixel_structure)
}

// .frame.proto.TextureFilter min_filter = 21;
inline bool Texture::_internal_has_min_filter() const {
  return this != internal_default_instance() && min_filter_ != nullptr;
}
inline bool Texture::has_min_filter() const {
  return _internal_has_min_filter();
}
inline void Texture::clear_min_filter() {
  if (GetArena() == nullptr && min_filter_ != nullptr) {
    delete min_filter_;
  }
  min_filter_ = nullptr;
}
inline const ::frame::proto::TextureFilter& Texture::_internal_min_filter() const {
  const ::frame::proto::TextureFilter* p = min_filter_;
  return p != nullptr ? *p : *reinterpret_cast<const ::frame::proto::TextureFilter*>(
      &::frame::proto::_TextureFilter_default_instance_);
}
inline const ::frame::proto::TextureFilter& Texture::min_filter() const {
  // @@protoc_insertion_point(field_get:frame.proto.Texture.min_filter)
  return _internal_min_filter();
}
inline void Texture::unsafe_arena_set_allocated_min_filter(
    ::frame::proto::TextureFilter* min_filter) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_filter_);
  }
  min_filter_ = min_filter;
  if (min_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.Texture.min_filter)
}
inline ::frame::proto::TextureFilter* Texture::release_min_filter() {
  
  ::frame::proto::TextureFilter* temp = min_filter_;
  min_filter_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::frame::proto::TextureFilter* Texture::unsafe_arena_release_min_filter() {
  // @@protoc_insertion_point(field_release:frame.proto.Texture.min_filter)
  
  ::frame::proto::TextureFilter* temp = min_filter_;
  min_filter_ = nullptr;
  return temp;
}
inline ::frame::proto::TextureFilter* Texture::_internal_mutable_min_filter() {
  
  if (min_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::TextureFilter>(GetArena());
    min_filter_ = p;
  }
  return min_filter_;
}
inline ::frame::proto::TextureFilter* Texture::mutable_min_filter() {
  // @@protoc_insertion_point(field_mutable:frame.proto.Texture.min_filter)
  return _internal_mutable_min_filter();
}
inline void Texture::set_allocated_min_filter(::frame::proto::TextureFilter* min_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete min_filter_;
  }
  if (min_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(min_filter);
    if (message_arena != submessage_arena) {
      min_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_filter, submessage_arena);
    }
    
  } else {
    
  }
  min_filter_ = min_filter;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.Texture.min_filter)
}

// .frame.proto.TextureFilter mag_filter = 22;
inline bool Texture::_internal_has_mag_filter() const {
  return this != internal_default_instance() && mag_filter_ != nullptr;
}
inline bool Texture::has_mag_filter() const {
  return _internal_has_mag_filter();
}
inline void Texture::clear_mag_filter() {
  if (GetArena() == nullptr && mag_filter_ != nullptr) {
    delete mag_filter_;
  }
  mag_filter_ = nullptr;
}
inline const ::frame::proto::TextureFilter& Texture::_internal_mag_filter() const {
  const ::frame::proto::TextureFilter* p = mag_filter_;
  return p != nullptr ? *p : *reinterpret_cast<const ::frame::proto::TextureFilter*>(
      &::frame::proto::_TextureFilter_default_instance_);
}
inline const ::frame::proto::TextureFilter& Texture::mag_filter() const {
  // @@protoc_insertion_point(field_get:frame.proto.Texture.mag_filter)
  return _internal_mag_filter();
}
inline void Texture::unsafe_arena_set_allocated_mag_filter(
    ::frame::proto::TextureFilter* mag_filter) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mag_filter_);
  }
  mag_filter_ = mag_filter;
  if (mag_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.Texture.mag_filter)
}
inline ::frame::proto::TextureFilter* Texture::release_mag_filter() {
  
  ::frame::proto::TextureFilter* temp = mag_filter_;
  mag_filter_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::frame::proto::TextureFilter* Texture::unsafe_arena_release_mag_filter() {
  // @@protoc_insertion_point(field_release:frame.proto.Texture.mag_filter)
  
  ::frame::proto::TextureFilter* temp = mag_filter_;
  mag_filter_ = nullptr;
  return temp;
}
inline ::frame::proto::TextureFilter* Texture::_internal_mutable_mag_filter() {
  
  if (mag_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::TextureFilter>(GetArena());
    mag_filter_ = p;
  }
  return mag_filter_;
}
inline ::frame::proto::TextureFilter* Texture::mutable_mag_filter() {
  // @@protoc_insertion_point(field_mutable:frame.proto.Texture.mag_filter)
  return _internal_mutable_mag_filter();
}
inline void Texture::set_allocated_mag_filter(::frame::proto::TextureFilter* mag_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete mag_filter_;
  }
  if (mag_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(mag_filter);
    if (message_arena != submessage_arena) {
      mag_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mag_filter, submessage_arena);
    }
    
  } else {
    
  }
  mag_filter_ = mag_filter;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.Texture.mag_filter)
}

// .frame.proto.TextureFilter wrap_s = 23;
inline bool Texture::_internal_has_wrap_s() const {
  return this != internal_default_instance() && wrap_s_ != nullptr;
}
inline bool Texture::has_wrap_s() const {
  return _internal_has_wrap_s();
}
inline void Texture::clear_wrap_s() {
  if (GetArena() == nullptr && wrap_s_ != nullptr) {
    delete wrap_s_;
  }
  wrap_s_ = nullptr;
}
inline const ::frame::proto::TextureFilter& Texture::_internal_wrap_s() const {
  const ::frame::proto::TextureFilter* p = wrap_s_;
  return p != nullptr ? *p : *reinterpret_cast<const ::frame::proto::TextureFilter*>(
      &::frame::proto::_TextureFilter_default_instance_);
}
inline const ::frame::proto::TextureFilter& Texture::wrap_s() const {
  // @@protoc_insertion_point(field_get:frame.proto.Texture.wrap_s)
  return _internal_wrap_s();
}
inline void Texture::unsafe_arena_set_allocated_wrap_s(
    ::frame::proto::TextureFilter* wrap_s) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wrap_s_);
  }
  wrap_s_ = wrap_s;
  if (wrap_s) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.Texture.wrap_s)
}
inline ::frame::proto::TextureFilter* Texture::release_wrap_s() {
  
  ::frame::proto::TextureFilter* temp = wrap_s_;
  wrap_s_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::frame::proto::TextureFilter* Texture::unsafe_arena_release_wrap_s() {
  // @@protoc_insertion_point(field_release:frame.proto.Texture.wrap_s)
  
  ::frame::proto::TextureFilter* temp = wrap_s_;
  wrap_s_ = nullptr;
  return temp;
}
inline ::frame::proto::TextureFilter* Texture::_internal_mutable_wrap_s() {
  
  if (wrap_s_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::TextureFilter>(GetArena());
    wrap_s_ = p;
  }
  return wrap_s_;
}
inline ::frame::proto::TextureFilter* Texture::mutable_wrap_s() {
  // @@protoc_insertion_point(field_mutable:frame.proto.Texture.wrap_s)
  return _internal_mutable_wrap_s();
}
inline void Texture::set_allocated_wrap_s(::frame::proto::TextureFilter* wrap_s) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete wrap_s_;
  }
  if (wrap_s) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(wrap_s);
    if (message_arena != submessage_arena) {
      wrap_s = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wrap_s, submessage_arena);
    }
    
  } else {
    
  }
  wrap_s_ = wrap_s;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.Texture.wrap_s)
}

// .frame.proto.TextureFilter wrap_t = 24;
inline bool Texture::_internal_has_wrap_t() const {
  return this != internal_default_instance() && wrap_t_ != nullptr;
}
inline bool Texture::has_wrap_t() const {
  return _internal_has_wrap_t();
}
inline void Texture::clear_wrap_t() {
  if (GetArena() == nullptr && wrap_t_ != nullptr) {
    delete wrap_t_;
  }
  wrap_t_ = nullptr;
}
inline const ::frame::proto::TextureFilter& Texture::_internal_wrap_t() const {
  const ::frame::proto::TextureFilter* p = wrap_t_;
  return p != nullptr ? *p : *reinterpret_cast<const ::frame::proto::TextureFilter*>(
      &::frame::proto::_TextureFilter_default_instance_);
}
inline const ::frame::proto::TextureFilter& Texture::wrap_t() const {
  // @@protoc_insertion_point(field_get:frame.proto.Texture.wrap_t)
  return _internal_wrap_t();
}
inline void Texture::unsafe_arena_set_allocated_wrap_t(
    ::frame::proto::TextureFilter* wrap_t) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wrap_t_);
  }
  wrap_t_ = wrap_t;
  if (wrap_t) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.Texture.wrap_t)
}
inline ::frame::proto::TextureFilter* Texture::release_wrap_t() {
  
  ::frame::proto::TextureFilter* temp = wrap_t_;
  wrap_t_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::frame::proto::TextureFilter* Texture::unsafe_arena_release_wrap_t() {
  // @@protoc_insertion_point(field_release:frame.proto.Texture.wrap_t)
  
  ::frame::proto::TextureFilter* temp = wrap_t_;
  wrap_t_ = nullptr;
  return temp;
}
inline ::frame::proto::TextureFilter* Texture::_internal_mutable_wrap_t() {
  
  if (wrap_t_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::TextureFilter>(GetArena());
    wrap_t_ = p;
  }
  return wrap_t_;
}
inline ::frame::proto::TextureFilter* Texture::mutable_wrap_t() {
  // @@protoc_insertion_point(field_mutable:frame.proto.Texture.wrap_t)
  return _internal_mutable_wrap_t();
}
inline void Texture::set_allocated_wrap_t(::frame::proto::TextureFilter* wrap_t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete wrap_t_;
  }
  if (wrap_t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(wrap_t);
    if (message_arena != submessage_arena) {
      wrap_t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wrap_t, submessage_arena);
    }
    
  } else {
    
  }
  wrap_t_ = wrap_t;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.Texture.wrap_t)
}

// bytes pixels = 30;
inline void Texture::clear_pixels() {
  pixels_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Texture::pixels() const {
  // @@protoc_insertion_point(field_get:frame.proto.Texture.pixels)
  return _internal_pixels();
}
inline void Texture::set_pixels(const std::string& value) {
  _internal_set_pixels(value);
  // @@protoc_insertion_point(field_set:frame.proto.Texture.pixels)
}
inline std::string* Texture::mutable_pixels() {
  // @@protoc_insertion_point(field_mutable:frame.proto.Texture.pixels)
  return _internal_mutable_pixels();
}
inline const std::string& Texture::_internal_pixels() const {
  return pixels_.Get();
}
inline void Texture::_internal_set_pixels(const std::string& value) {
  
  pixels_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Texture::set_pixels(std::string&& value) {
  
  pixels_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:frame.proto.Texture.pixels)
}
inline void Texture::set_pixels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pixels_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:frame.proto.Texture.pixels)
}
inline void Texture::set_pixels(const void* value,
    size_t size) {
  
  pixels_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:frame.proto.Texture.pixels)
}
inline std::string* Texture::_internal_mutable_pixels() {
  
  return pixels_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Texture::release_pixels() {
  // @@protoc_insertion_point(field_release:frame.proto.Texture.pixels)
  return pixels_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Texture::set_allocated_pixels(std::string* pixels) {
  if (pixels != nullptr) {
    
  } else {
    
  }
  pixels_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pixels,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:frame.proto.Texture.pixels)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace frame

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::frame::proto::TextureFilter_Enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::frame::proto::TextureFilter_Enum>() {
  return ::frame::proto::TextureFilter_Enum_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Texture_2eproto
